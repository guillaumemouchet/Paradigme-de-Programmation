
package ch.hearc.SA.labo1.tools;

import java.util.ArrayList;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.FutureTask;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.locks.ReentrantLock;
import java.util.stream.IntStream;

import ch.hearc.SA.labo1.tools.Log.Action;
import ch.hearc.SA.labo1.tools.Log.Type;

public class WaitingLogger
	{

	/*------------------------------------------------------------------*\
	|*							Constructeurs							*|
	\*------------------------------------------------------------------*/

	private WaitingLogger()
		{
		//Helpers
		db = Database.getInstance();

		//BlockingQueue
		finishedQueue = new LinkedBlockingQueue<Person>();
		logsQueue = new LinkedBlockingQueue<Log>();
		processingQueue = new LinkedBlockingQueue<Person>();
		waitingQueue = new LinkedBlockingQueue<Person>();

		//Display
		finishedListDisplay = new ArrayList<Person>();
		processingListDisplay = new ArrayList<Person>();
		waitingListDisplay = new ArrayList<Person>();
		logsListDisplay = new ArrayList<Log>();

		}

	/*------------------------------------------------------------------*\
	|*							Methodes Public							*|
	\*------------------------------------------------------------------*/

	/**
	 * Assign the future task to be able to cancel it when all threads are done
	 * @param consoleFuture Future task running the main thread
	 * @param persons List of persons generated by the main thread
	 */
	public void assignConsoleFuture(FutureTask<String> consoleFuture, ArrayList<Person> persons)
		{
		this.consoleFuture = consoleFuture;
		this.persons = persons;
		}

	/**
	 * Add a thread to the waiting queue
	 * @param p Person waiting to access a document
	 * @param timer Time of the operation
	 */
	public void addWaiting(Person p, long timer)
		{
		/*
		 * -----------------------------------------------------------------------------------
		 * DONE : 1) Ajouter une personne (thread) dans la liste d'attente d'acces a son document
		 *
		 * Remarque : ne pas oublier la concurrence
		 * -----------------------------------------------------------------------------------
		 */
		try
			{
			waitingQueue.put(p); //1)
			this.sleep(timer);
			}
		catch (InterruptedException e)
			{
			System.out.println("Thread " + Thread.currentThread().getId() + " is interrupted");
			}

		logsQueue.add(new Log(Log.Type.WAITING, p, Log.Action.PUT));
		}

	/**
	 * Remove a thread from the waiting queue and add it to the processing queue
	 * @param p Person accessing the document
	 * @param timer Time of the operation
	 */
	public void removeWaiting(Person p, long timer)
		{
		/*
		 * ---------------------------------------------------------------------------------
		 * DONE : 1) Enlever une personne (thread) de la liste d'attente d'acces a son document
		 * 		  2) Ajouter une personne (thread) dans la liste de traitement du document
		 *
		 * Remarque : ne pas oublier la concurrence
		 * ---------------------------------------------------------------------------------
		 */

		try
			{
			waitingQueue.remove(p); //1)
			processingQueue.put(p); //2)
			this.sleep(timer);

			}
		catch (InterruptedException e)
			{
			System.out.println("Thread " + Thread.currentThread().getId() + " is interrupted");
			}

		logsQueue.add(new Log(Log.Type.WAITING, p, Log.Action.REMOVE));
		logsQueue.add(new Log(Log.Type.PROCESSING, p, Log.Action.PUT));

		}

	/**
	 * Remove a thread from the processing queue
	 * @param p Person finishing to access the document
	 * @param timer Time of the operation
	 */
	public void finished(Person p, long timer)
		{
		/*
		 * --------------------------------------------
		 * Done : 	1) Enlever de la liste de process
		 * 			2) Indiquer la fin d'acces a un document
		 *
		 * Remarque : ne pas oublier la concurrence
		 * --------------------------------------------
		 */

		this.sleep(timer);
		try
			{
			processingQueue.remove(p); //1)
			finishedQueue.put(p); //2)
			}
		catch (InterruptedException e)
			{
			System.out.println("Thread " + Thread.currentThread().getId() + " is interrupted");
			}

		logsQueue.add(new Log(Log.Type.PROCESSING, p, Log.Action.REMOVE));
		logsQueue.add(new Log(Log.Type.FINISHED, p, Log.Action.FINISHED));

		}

	/**
	 * Called by the user on typing 'NEXT', display the next operation logged
	 */
	public void popNextLog()
		{
		Log nextLog = null;

		//Check if their is something to display
		while(logsQueue.size() == 0)
			{
			if (finishedQueue.size() != persons.size())
				{
				System.out.println("No Logging in queue, waiting");
				sleep(1000);
				}
			}

		/*
		 * -----------------------------------------------------------------------------------------------------------
		 * done : 1) Recuperer le prochain log du stockage pour le traitement
		 *
		 * Remarque : a vous de definir votre type de stockage selon l'UI et l'infrastructure que vous voulez utiliser
		 * -----------------------------------------------------------------------------------------------------------
		 */

		nextLog = logsQueue.poll(); //1)

		//The display are seperated in different functions
		/*
		 * All displays where inspired by the demo video for the project
		 */
		printThread(persons);
		printQueueStates(nextLog);
		printDiagram(persons);
		printAction(nextLog);

		stepCounter++;

		/*
		 * -----------------------------------------------------------------------------------------------------------------------------------
		 * DONE : 1) Controller si il s'agit du dernier log, arreter le programme si c'est le cas
		 *
		 * Remarque : interrompre consoleFuture
		 *            (2 conditions doivent etre reunies : logs == 0 et nombre de threads termines correspondant aux nombre total de personnes)
		 * -----------------------------------------------------------------------------------------------------------------------------------
		 */
		if (logsQueue.size() == 0 && finishedQueue.size() == persons.size()) //1)
			{
			System.out.println("The execution has come to an end");
			consoleFuture.cancel(true);
			}
		}



	/*------------------------------*\
	|*				Get				*|
	\*------------------------------*/

	public static WaitingLogger getInstance()
		{
		lockSingleton.lock();
		if (instance == null)
			{
			instance = new WaitingLogger();
			}
		lockSingleton.unlock();

		return instance;
		}

	/*------------------------------------------------------------------*\
	|*							Methodes Private						*|
	\*------------------------------------------------------------------*/

	/*
	 * Show all threads as well with their start time and duration
	 */
	private void printThread(ArrayList<Person> persons)
		{
		// Print threads
		System.out.println();
		System.out.println("---- Threads list ----------------------------------------------");
		System.out.println();
		persons.stream()//
				.forEach(person -> System.out.println(//
						person.getName() //
						+ " (" + person.getRole() //
						+ ") start : " + person.getStartingTime() //
						+ " / duration : " + person.getDurationTime() //
						+ " (" + person.getDocument().getName() + ")"));
		}

	/*
	 * Show the state of the Queue
	 * They use they own display list to have a one by one display
	 * They don't show the transition when a Person is removed (the Person is just not visible)
	 * He well reapear once a PUT is called
	 */
	private void printQueueStates(Log nextLog)
		{
		updateListDisplay(nextLog.getType(), nextLog.getPerson(), nextLog.getAction());

		// Print Queue states
		System.out.println();
		System.out.println("---- Queue states ----------------------------------------------");
		System.out.println();

		for(Document document:db.getDocuments())
			{
			System.out.print(document.getName() + " (WAITING)\t: ");
			waitingListDisplay.stream()//
					.filter(person -> person.getDocument().equals(document))//
					.forEach(person -> System.out.print(//
							person.getName() + " (" + person.getRole().toString().charAt(0) + ") "));
			System.out.println();

			System.out.print(document.getName() + " (PROCESSING)\t: ");
			processingListDisplay.stream().filter(//
					person -> person.getDocument().equals(document))//
					.forEach(person -> System.out.print(//
							person.getName() + " (" + person.getRole().toString().charAt(0) + ") "));
			System.out.println();

			System.out.print(document.getName() + " (FINISHED)\t: ");
			finishedListDisplay.stream().filter(//
					person -> person.getDocument().equals(document))//
					.forEach(person -> System.out.print(//
							person.getName() + " (" + person.getRole().toString().charAt(0) + ") "));
			System.out.println();
			System.out.println();

			}
		}

	private void printDiagram(ArrayList<Person> persons)
		{
		// Print Diagram

		System.out.println();
		System.out.println("---- Diagram ---------------------------------------------------");
		System.out.println();

		System.out.println("W: Waiting / R: Removed from waiting / P: Processing / F: Finished");
		System.out.println();
		System.out.print("Step\t\t\t");
		IntStream.range(0, stepCounter).forEach(i -> System.out.print(i + "\t"));
		System.out.println();

		for(Person person:persons)
			{
			System.out.print(person.getName() + " " + "(" + person.getRole() + ")\t");
			int lastPosition = 0;
			Log log = null;
			for(int i = 0; i < logsListDisplay.size(); i++)
				{
				if (logsListDisplay.get(i).getPerson() == person)
					{
					log = logsListDisplay.get(i);
					if (logsListDisplay.get(lastPosition).getAction() == Action.PUT && logsListDisplay.get(lastPosition).getPerson() == person)
						{
						System.out.print("--------".repeat(Math.abs(i - lastPosition)));
						}
					else
						{
						System.out.print("\t".repeat(Math.abs(i - lastPosition)));
						}

					lastPosition = i;
					System.out.print(log.getType() == Type.WAITING && log.getAction() == Action.REMOVE ? "R" : log.getType().toString().charAt(0));
					}
				}
			System.out.println();
			}
		}

	private void printAction(Log nextLog)
		{
		System.out.println();

		// Treat log type
		String action = "";
		switch(nextLog.getAction())
			{
			case PUT:
				action = "put in";
				break;
			case REMOVE:
				action = "removed from";
				break;
			case FINISHED:
				action = "finished";
				break;
			default:
			}
		switch(nextLog.getType())
			{

			case WAITING:
				System.out.println(">>>> Thread (" + nextLog.getPerson().getName() + ") " + action + " waiting for " + nextLog.getPerson().getDocument().getName());

				break;
			case PROCESSING:

				System.out.println(">>>> Thread (" + nextLog.getPerson().getName() + ") " + action + " processing the " + nextLog.getPerson().getDocument().getName());

				break;
			case FINISHED:

				System.out.println(">>>> Thread (" + nextLog.getPerson().getName() + ") " + action + " the end of all the actions " + nextLog.getPerson().getDocument().getName());

				break;
			default:
				System.out.println(">>>> Thread (" + nextLog.getPerson().getName() + ") is doing non conventionnal actions");

				break;
			}
		System.out.println();

		}

	private void updateListDisplay(Log.Type type, Person person, Action action)
		{

		// Update lists
		switch(action)
			{
			case PUT:
				switch(type)
					{
					case WAITING:
						logsListDisplay.add(new Log(Log.Type.WAITING, person, Log.Action.PUT));

						waitingListDisplay.add(person);
						break;
					case PROCESSING:
						logsListDisplay.add(new Log(Log.Type.PROCESSING, person, Log.Action.PUT));

						processingListDisplay.add(person);
						break;
					case FINISHED:
						logsListDisplay.add(new Log(Log.Type.FINISHED, person, Log.Action.PUT));

						finishedListDisplay.add(person);
						break;
					default:
					}
				break;
			case REMOVE:
				switch(type)
					{
					case WAITING:
						logsListDisplay.add(new Log(Log.Type.WAITING, person, Log.Action.REMOVE));

						waitingListDisplay.remove(person);
						break;
					case PROCESSING:
						logsListDisplay.add(new Log(Log.Type.PROCESSING, person, Log.Action.REMOVE));

						processingListDisplay.remove(person);
						break;
					case FINISHED:
						logsListDisplay.add(new Log(Log.Type.FINISHED, person, Log.Action.REMOVE));

						finishedListDisplay.remove(person);
						break;
					default:
					}
			case FINISHED:
				switch(type)
					{
					case WAITING:
						//NEVER CALLED
						break;
					case PROCESSING:
						//NEVER CALLED
						break;
					case FINISHED:
						logsListDisplay.add(new Log(Log.Type.FINISHED, person, Log.Action.FINISHED));
						break;
					default:
					}
				break;
			default:
			}
		}

	/**
	 * Sleep for a certain given time
	 * @params timeDuration : time the Threads is sleeping
	 **/
	private void sleep(long timeDuration)
		{

		try
			{
			Thread.sleep(timeDuration);
			}
		catch (InterruptedException e)
			{
			System.out.println("Thread " + Thread.currentThread().getId() + " is interrupted");
			}

		}
	/*------------------------------------------------------------------*\
	|*							Attributs Private						*|
	\*------------------------------------------------------------------*/

	// Singleton lock
	private final static ReentrantLock lockSingleton = new ReentrantLock();
	private static WaitingLogger instance;
	/*
	 * -----------------------------------------------------------------------------------------------
	 * Done : Prevoir un stockage concurrent pour les logs et pour les listes d'attente des documents
	 *
	 * Remarque : java.util.concurrent contient tout ce qu'il faut
	 * -----------------------------------------------------------------------------------------------
	 */

	// BlockginQueue to have a concurrent storage
	private BlockingQueue<Log> logsQueue;
	private BlockingQueue<Person> finishedQueue;
	private BlockingQueue<Person> processingQueue;
	private BlockingQueue<Person> waitingQueue;

	//Similar to their BlockingQueu but don't pop the actions to display them one by one
	private ArrayList<Log> logsListDisplay;
	private ArrayList<Person> finishedListDisplay;
	private ArrayList<Person> processingListDisplay;
	private ArrayList<Person> waitingListDisplay;

	// Variables
	private ArrayList<Person> persons;
	// Singletons
	private Database db;

	private FutureTask<String> consoleFuture;
	private static int stepCounter = 1;

	}
