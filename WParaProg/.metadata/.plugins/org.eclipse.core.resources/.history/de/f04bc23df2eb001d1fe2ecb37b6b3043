
package ch.hearc.SA.labo2.BlockingQueue.Performance;

import java.util.ArrayList;

/*
 * Les performances définissent la quantité de travail qu'une application peut traiter pendant une certaine période et la vitesse à laquelle elle peut traiter une unité de travail.
 * La latence est le temps nécessaire pour effectuer une action ou pour produire un résultat.
 * Le débit est le nombre d'actions exécutées, de résultats d'actions exécutées ou de résultats produits par unité de temps.
 */
public class CalculatorPerformance
	{

	private static double latencyCreate; //latence
	private static double latencySort; //latence
	private static double debitSort; //débit
	private static double debitCreate; //débit
	private static double nbActions; //performance

	public static void createReport(@SuppressWarnings("unused") int nbProducteurs, @SuppressWarnings("unused") int nbConsommateurs,@SuppressWarnings("unused")  int queueSize, long executionTime)
		{
		ArrayList<Long> shuffleTimes = TimePerformance.getInstance().getArrayCreateTimes();
		ArrayList<Long> sortTimes = TimePerformance.getInstance().getArraySortTimes();
		debitSort = (double)sortTimes.size() / (executionTime/1000); //execution time is in miliseconds, we want seconds
		debitCreate = (double)shuffleTimes.size() / (executionTime/1000);
		latencyCreate = shuffleTimes.stream().mapToLong(i -> i).average().getAsDouble();
		latencySort = sortTimes.stream().mapToLong(i -> i).average().getAsDouble();
		nbActions = sortTimes.size()+shuffleTimes.size();
		}

	public static ArrayList<Double> getImportantValues()
		{
		ArrayList<Double> values = new ArrayList<>();
		values.add(nbActions);
		values.add(debitSort);
		values.add(debitCreate);
		values.add(latencySort);
		values.add(latencyCreate);

		return values;
		}
	}
